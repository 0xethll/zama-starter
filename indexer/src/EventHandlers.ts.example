/*
 * Envio Event Handlers for Confidential Token Factory
 */
import {
  ConfidentialTokenFactory,
  ConfidentialERC20Wrapper,
  ConfidentialTokenFactory_TokenWrapped,
  ConfidentialTokenRegistry,
  ConfidentialERC20Wrapper_ConfidentialTransfer,
  ConfidentialERC20Wrapper_UnwrapRequest,
} from "generated";

// ============ Factory Event Handlers ============

/**
 * Dynamically register newly created confidential token contracts
 * Automatically registers new contract addresses when Factory emits TokenWrapped event
 */
ConfidentialTokenFactory.TokenWrapped.contractRegister(({ event, context }) => {
  context.addConfidentialERC20Wrapper(event.params.confidentialToken);
});

/**
 * Handle TokenWrapped event
 * Record newly created confidential token and create Registry entry
 */
ConfidentialTokenFactory.TokenWrapped.handler(async ({ event, context }) => {
  const { erc20Token, confidentialToken, name, symbol, creator } = event.params;

  // 1. Save TokenWrapped event
  const wrappedEvent: ConfidentialTokenFactory_TokenWrapped = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    erc20Token,
    confidentialToken,
    name,
    symbol,
    creator,
    createdAt: BigInt(event.block.timestamp),
    blockNumber: BigInt(event.block.number),
    transactionHash: event.transaction.hash,
  };
  context.ConfidentialTokenFactory_TokenWrapped.set(wrappedEvent);

  // 2. Create Token Registry
  const registry: ConfidentialTokenRegistry = {
    id: confidentialToken,
    erc20Token,
    name,
    symbol,
    creator,
    createdAt: BigInt(event.block.timestamp),
    totalTransfers: 0n,
    totalUnwrapRequests: 0n,
  };
  context.ConfidentialTokenRegistry.set(registry);
});

// ============ ERC7984 Event Handlers ============

/**
 * Handle confidential transfer event
 */
ConfidentialERC20Wrapper.ConfidentialTransfer.handler(async ({ event, context }) => {
  const contractAddress = event.srcAddress;

  const entity: ConfidentialERC20Wrapper_ConfidentialTransfer = {
    id: `${event.chainId}_${event.block.number}_${event.logIndex}`,
    contractAddress,
    from: event.params.from,
    to: event.params.to,
    amount: event.params.amount,
    blockNumber: BigInt(event.block.number),
    timestamp: BigInt(event.block.timestamp),
    transactionHash: event.transaction.hash,
  };
  context.ConfidentialERC20Wrapper_ConfidentialTransfer.set(entity);

  // Update statistics
  const registry = await context.ConfidentialTokenRegistry.get(contractAddress);
  if (registry) {
    registry.totalTransfers += 1n;
    context.ConfidentialTokenRegistry.set(registry);
  }
});

/**
 * Handle unwrap request event
 */
ConfidentialERC20Wrapper.UnwrapRequested.handler(async ({ event, context }) => {
  const contractAddress = event.srcAddress;
  const burntAmount = event.params.amount;

  const entity: ConfidentialERC20Wrapper_UnwrapRequest = {
    id: `${contractAddress}_${burntAmount}`,
    contractAddress,
    burntAmount,
    recipient: event.params.receiver,
    requestBlockNumber: BigInt(event.block.number),
    requestTransactionHash: event.transaction.hash,
    requestTimestamp: BigInt(event.block.timestamp),
    isFinalized: false,
  };
  context.ConfidentialERC20Wrapper_UnwrapRequest.set(entity);

  // Update statistics
  const registry = await context.ConfidentialTokenRegistry.get(contractAddress);
  if (registry) {
    registry.totalUnwrapRequests += 1n;
    context.ConfidentialTokenRegistry.set(registry);
  }
});

/**
 * Handle unwrap finalized event
 */
ConfidentialERC20Wrapper.UnwrapFinalized.handler(async ({ event, context }) => {
  const contractAddress = event.srcAddress;
  const burntAmount = event.params.encryptedAmount;
  const id = `${contractAddress}_${burntAmount}`;

  const existingRequest = await context.ConfidentialERC20Wrapper_UnwrapRequest.get(id);

  if (existingRequest) {
    const updatedEntity: ConfidentialERC20Wrapper_UnwrapRequest = {
      ...existingRequest,
      isFinalized: true,
      cleartextAmount: event.params.cleartextAmount,
      finalizedBlockNumber: BigInt(event.block.number),
      finalizedTransactionHash: event.transaction.hash,
      finalizedTimestamp: BigInt(event.block.timestamp),
    };
    context.ConfidentialERC20Wrapper_UnwrapRequest.set(updatedEntity);
  } else {
    // If no corresponding request found, create a new one (should not happen in normal flow)
    console.warn(`UnwrapFinalized for ${burntAmount} but no request found`);
    const entity: ConfidentialERC20Wrapper_UnwrapRequest = {
      id,
      contractAddress,
      burntAmount,
      recipient: event.params.receiver,
      requestBlockNumber: BigInt(event.block.number),
      requestTransactionHash: event.transaction.hash,
      requestTimestamp: BigInt(event.block.timestamp),
      isFinalized: true,
      cleartextAmount: event.params.cleartextAmount,
      finalizedBlockNumber: BigInt(event.block.number),
      finalizedTransactionHash: event.transaction.hash,
      finalizedTimestamp: BigInt(event.block.timestamp),
    };
    context.ConfidentialERC20Wrapper_UnwrapRequest.set(entity);
  }
});
